# grpc
## 组成
1. 客户端(client): 服务端的调用方
2. 服务端(Server): 真正的服务端提供方
3. 客户端存根(ClientOption): socket管理, 网络收发包的序列化
4. 服务端存根(ServerOption): socket管理, 提醒server层rpc方法调用, 以及网络是收发包的序列化  

逻辑图让如下:
![](./rpc%E9%80%BB%E8%BE%91%E5%9B%BE.png)
## 什么是grpc
grpc是rpc的一种, 它使用的是protocol buffer作为序列化格式. protocol buffer比json更加轻便高效, 同时基于http/2. 使用protoc就能使用proto文件帮助我们生成option层代码.

```
    http/1.1和http/2的区别
    1. http/2采用的是二进制传输的而不是文本
        - 解析高效
    2. http/2 采用的是完全多路复用, 只需要一个连接就可以实现并行操作
        - http/1.x有一个问题是线端阻塞, 一个连接一次只提交一个请求的效率比较高, 但是多了就会变慢;
        - http/1.x 尝试使用了流水线来解决这个问题, 但是当传输的第一个数据量比较大的时候就会出现后一个需要传输的数据的及时性.
        - 多路传输可以同时处理多个消息的请求和传输; 甚至可以在传输的过程中将一个消息跟另外一个消息掺杂在一起.所以客户端只需要建立一次连接就可以加载一个页面.
    3. 使用报头压缩, 降低开销 
        - 
    4. http/2可以让服务器将响应主动推送到客户端缓存中
        - 当浏览器请求一个网页的时候, 服务器就会发送html等资源, 但是在这之前, 服务器需要浏览器去解析资源的请求.服务器推送的内容是服务端认为客户端需要的资源, 以此避免往返的延迟.   
```
grpc 调用模型
![](./grpc%E8%B0%83%E7%94%A8%E6%A8%A1%E5%9E%8B.png)
### 适用场景
1. 多语言混合开发: 使用同一套rpc接口
2. 网络受限: protobuf 序列化之后的消息就会比等效的json消息要小.
3. 分布式场景: gRPC设计为低延迟和高吞吐量通信，非常适用于效率至关重要的轻型微服务。
4. 点对点实时通信: gRPC对双向流媒体提供出色的支持，可以实时推送消息而无需轮询。