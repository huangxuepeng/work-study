# Docker
## image 镜像
1. 介绍：
-  一个只读层被称为一个镜像, 一个镜像是永远不会改变的.分层组成的, 前一个镜像就是后一个而镜像的父镜像,因为后一个是基于前一个构成的. 可以在dockerfile中体现出来, 首先要from 一个你想要构建成的镜像的基础镜像, 每次执行一次run命令, 都会在原有的基础上执行, 并且提交为新的镜像.
    - 分层的原因: 共享资源. 比如多个镜像都是由base镜像构建而来的, 那么我们只需要在磁盘上保存一份, 内存上保存一份就可以供所有的镜像使用.
        ``` 
         虽然共享的, 但是修改一个镜像的内容时, 不会对其他的镜像有所影响.
            1. 新的数据是存放在读写层的
            2. 当只读层中存在和读写层由相同的命名文件的时候, 用户只能看见读写层的数据
            3. 当需要修改只读层的时候, 需要将只读层的数据复制到读写层, 而后进行修改, 但是修改的数据只能保留在读写层,而这次的修改只能在这个容器内使用, 如果让其他人也想使用这个容器, 需要将容器打包成镜像.
            
        ```
- 一个运行起来的叫做容器, 它是由镜像加了一个读写层完成的, 需要挂在文件, 所以所有的操作都是发生在读写层的, 镜像永远不会改变.
- 当一个镜像不存在父镜像的时候那么这个镜像就是基础镜像(base镜像)
    - base镜像
        - 不依赖其他其他镜像, 从scratch构建
            - scratch是专门构建最小镜像的
        - 其他的镜像都是以它为基础进行构建的 
## 安全介绍
1. 内核名字空间: 
    - 隔离空间, 让容器中运行的进程不被主机的的进程和其容器的进程发现和作用.
    - 如果实现交互, 可以通过link两个容器就可以实现容器之间的交互
2. 控制组
    - 资源限制：设置每一个容器的占用内存的上限
    - 优先级： 可以让一些优先级的高的容器优先获得更多的cpu资源
    - 控制组可以保证容器内部的压力不会影响主机
    - 可以防止`拒绝攻击服务`方面不可少
        > 攻击者加载过多的服务器资源,导致服务器资源剩余过少, 使得其他用户无法使用
3. Docker服务端的防护
4. 内核能力机制
5. 其他安全特性
## dockerfile 
1. FROM 指定一个基础镜像
2. RUN 每次执行都会提交一个新的镜像, 在原来的镜像上新添加一层只读层
3. CMD 当有多个CMD的时候只会执行最后一条CMD命令, 当容器启动时指定了运行的命令, 自动忽略CMD的命令
4. ENV 环境变量
5. COPY ADD <src> <dest> 复制src到容器中的<dest> <src>是dockerfile所在文件夹的相对地址 
## 底层实现
1. 基本架构： 
    - c/s架构（客户端服务端）
    - docker daemon 一般运行在宿主机上, 作为服务器处理用户发起的请求
    - 也可以通过socket和rest 接口进行通信

## etcd
1. 什么是etcd？
- 高可用的分布式键值（k-v）数据库。
- 设计
    - 简单：支持rest风格的http+json api
    - 安全：支持https访问
    - 快速： 支持并发1k/s的写操作
    - 可靠： 支持分布式结构， 基于`raft`(应对机器的故障)的一致性算法
- 用户可以在多个节点上启动多个实例，并且添加他为一个集群
2. 使用场景
- 服务的注册与发现
    - 服务发现就是要了解集群中是否有进程在监听udp 或者 tcp 端口，且通过名字就可以进行查找和链接
- 键值对储存
    - 比关系型数据库要快
    - 支持静态储存和动态储存
    - 分布式存储，可以成为多节点集群
    - 存储方式类似于目录结构
        - 只有叶子节点才能存储数据
        - 叶子节点的父节点是目录，不能存储数据
    - 会有延迟， 延迟的原因的是raft的速度是和大多数机器的最慢的一样快, 可以适当的调节集群缓解此问题
## docker Daemon
