# Docker
## image 镜像
1. 介绍：
-  一个只读层被称为一个镜像, 一个镜像是永远不会改变的.分层组成的, 前一个镜像就是后一个而镜像的父镜像,因为后一个是基于前一个构成的. 可以在dockerfile中体现出来, 首先要from 一个你想要构建成的镜像的基础镜像, 每次执行一次run命令, 都会在原有的基础上执行, 并且提交为新的镜像.
    - 分层的原因: 共享资源. 比如多个镜像都是由base镜像构建而来的, 那么我们只需要在磁盘上保存一份, 内存上保存一份就可以供所有的镜像使用.
        ``` 
         虽然共享的, 但是修改一个镜像的内容时, 不会对其他的镜像有所影响.
            1. 新的数据是存放在读写层的
            2. 当只读层中存在和读写层由相同的命名文件的时候, 用户只能看见读写层的数据
            3. 当需要修改只读层的时候, 需要将只读层的数据复制到读写层, 而后进行修改, 但是修改的数据只能保留在读写层,而这次的修改只能在这个容器内使用, 如果让其他人也想使用这个容器, 需要将容器打包成镜像.
            
        ```
- 一个运行起来的叫做容器, 它是由镜像加了一个读写层完成的, 需要挂在文件, 所以所有的操作都是发生在读写层的, 镜像永远不会改变.
- 当一个镜像不存在父镜像的时候那么这个镜像就是基础镜像(base镜像)
    - base镜像
        - 不依赖其他其他镜像, 从scratch构建
            - scratch是专门构建最小镜像的
        - 其他的镜像都是以它为基础进行构建的 
## 安全介绍
1. 内核名字空间: 
    - 隔离空间, 让容器中运行的进程不被主机的的进程和其容器的进程发现和作用.
    - 如果实现交互, 可以通过link两个容器就可以实现容器之间的交互
2. 控制组
    - 资源限制：设置每一个容器的占用内存的上限
    - 优先级： 可以让一些优先级的高的容器优先获得更多的cpu资源
    - 控制组可以保证容器内部的压力不会影响主机
    - 可以防止`拒绝攻击服务`方面不可少
        > 攻击者加载过多的服务器资源,导致服务器资源剩余过少, 使得其他用户无法使用
3. Docker服务端的防护
4. 内核能力机制
5. 其他安全特性
## dockerfile 
1. FROM 指定一个基础镜像
2. RUN 每次执行都会提交一个新的镜像, 在原来的镜像上新添加一层只读层
3. CMD 当有多个CMD的时候只会执行最后一条CMD命令, 当容器启动时指定了运行的命令, 自动忽略CMD的命令
4. ENV 环境变量
5. COPY ADD <src> <dest> 复制src到容器中的<dest> <src>是dockerfile所在文件夹的相对地址 
## 底层实现
1. 基本架构： 
    - c/s架构（客户端服务端）
    - docker daemon 一般运行在宿主机上, 作为服务器处理用户发起的请求
    - 也可以通过socket和rest 接口进行通信

## etcd
1. 什么是etcd？
- 高可用的分布式键值（k-v）数据库。
- 设计
    - 简单：支持rest风格的http+json api
    - 安全：支持https访问
    - 快速： 支持并发1k/s的写操作
    - 可靠： 支持分布式结构， 基于`raft`(应对机器的故障)的一致性算法
- 用户可以在多个节点上启动多个实例，并且添加他为一个集群
2. 使用场景
- 服务的注册与发现
    - 服务发现就是要了解集群中是否有进程在监听udp 或者 tcp 端口，且通过名字就可以进行查找和链接
- 键值对储存
    - 比关系型数据库要快
    - 支持静态储存和动态储存
    - 分布式存储，可以成为多节点集群
    - 存储方式类似于目录结构
        - 只有叶子节点才能存储数据
        - 叶子节点的父节点是目录，不能存储数据
    - 会有延迟， 延迟的原因的是raft的速度是和大多数机器的最慢的一样快, 可以适当的调节集群缓解此问题
## docker Daemon
1. 它是docker的守护进程,Docker Client通过命令行与Docker Daemon 通信, 完成Docker相关操作.
2. 主要功能是: 镜像管理, 镜像构建, REST API, 身份验证, 安全, 核心网络以及编排
### 工作机制
1. 可以认为是通过docker server 模块接受docker client的请求, 并且在engine中处理请求, 然后根据类型, 创建出指定的job并且运行.
### 启动流程
1. docker daemon和docker client 的启动都是通过可执行文件来完成的, 所以二者的过程相似, 二者运行的时候通过flag参数解析二者的区别, 并且各自执行自己的.
2. 
### 总结
1. 宏观上: mainDaemon中创建一个daemon进程,使得docker daemon可以正常进行.
2. 功能上: mainDaemon 的主要功能是生成docker的运行环境; 服务于docker client, 接受请求并且处理
3. 细节上的步骤实现: 
    - daemon的配置初始化
        - 定义一个String类型的flag参数
        - 该参数的名称是 "p"或者"-pidfile"
        - 该flag的默认值为"/var/run/docker.pid"(进程的pid), 并将该值绑定在变量config.Pidfile上 
    - 命令行flag参数检查
        - docker 命令经过flag参数解析后, docker判断剩余的参数是否为0. 若为0, 表示启动命令无误, 如果不为0, 就会退出程序.
    - 创建engine对象
    - 设置engine的信号捕获及处理方法
    - 加载builtins
        - docker daemon运行过程中, 注册一些任务, 这部分任务一般于容器的运行无关, 与Docker Daemon的运行时信息有关.
    - 使用goroutine加载daemon对象并且运行
    - 打印docker 版本及驱动信息
    - job之"serveapi"的创建与运行
## docker 容器之间进行通信
### 通过容器ip访问
### 通过宿主机的ip:port访问
通过宿主机的ip:port访问, 只能依靠监听在暴露出的端口进行有限的通信
### 通过link建立连接(不推荐)
### 通过网桥通信(推荐)
1. docker 的bridge 自定义网络之间默认是有域名解析的;
2. docker 的bridge自定义网络与系统自带的网桥之间默认是由解析的
3. docker 系统自带的网桥之间默认是没有解析的