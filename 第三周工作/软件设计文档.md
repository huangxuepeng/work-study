## 项目概述
1. 与15s软件商店同步
2. 与软件安装部署同步
3. 实现对软件段的管理
4. 对软件段的卸载/删除
5. 对软件段的删除, 安装, 卸载等操作要使用异步处理的方式同步到sdp
## 总体设计
![总体图](../%E7%AC%AC%E4%B8%89%E5%91%A8%E5%B7%A5%E4%BD%9C/%E8%AE%BE%E8%AE%A1%E6%80%BB%E4%BD%93.png)
### 软件段创建
1. 软件段创建前由前端调用接口判断该段是否已经存在，存在则直接提示用户段已存在，不存在则进入2
2. 前端调用上传段接口，传入段文件，后端通过软件段的后缀判断压缩方式, 如果后缀是mpk, 将此软件段同步到15s; 如果是zip, 将此软件段同步到软件安装部署.服务端解析段文件获取元信息，判断段是否已经存在，已经存在的段直接返回段已存在；否则，保存段文件到共享存储，并创建段记录（包含段的元信息）写入etcd
3. 控制器监听到etcd段新增事件后，通过`SDP client`调用rpc接口在`SDP`中同步新增段，更新同步创建的结果（状态、时间、失败原因等），，如果失败了，则间隔一段时间后进行重试并累加重试次数，直到创建成功或者重试次数超过阈值，重试次数和间隔时间可配置；成功同步时，更新etcd段记录中的`remoteExtra`字段信息，包括段在`SDP`中的id等
![软件段创建](../%E7%AC%AC%E4%B8%89%E5%91%A8%E5%B7%A5%E4%BD%9C/%E8%BD%AF%E4%BB%B6%E6%AE%B5%E5%88%9B%E5%BB%BA.png)
### 删除段
1. 用户请求删除段, 调用服务端删除段接口, 传入软件段id
2. 服务端通过id获取软件段信息
    - 判断软件段是否存在, 若不存在直接返回错误信息, 若存在直接执行3
    - 首先判断段记录的`deleteStatus`，如果其为`Processing`，则直接返回前端删除成功（已经在删除中，无需重复提交）
    - 接着判断段是否已安装或者正在安装，已安装或者正在安装的段直接返回段已安装，不可删除；否则，将段记录的`deleteStatus`字段置为`Processing`，更新etcd中该记录
3. 控制器监听到etcd段记录更新事件，通过更新前后的段记录`deleteStatus`字段判断是否为段删除，是则执行步骤4，否则不做处理
4. 通过`SDP client`调用rpc接口传入段在`SDP`中的id，在`SDP`中同步删除段，删除成功后直接删除etcd中该条段记录，并且删除段安装记录和段安装日志中的相应记录以及共享存储中的段文件；否则，将etcd中该条段记录的`deleteStatus`字段置为`failed`，并记录删除失败原因
![删除段](../%E7%AC%AC%E4%B8%89%E5%91%A8%E5%B7%A5%E4%BD%9C/%E5%88%A0%E9%99%A4%E6%AE%B5.png)
### 获取软件段列表
1. 用户请求获取段列表, 调用服务端的获取列表接口, 用户上传需求
2. 用户可以进行多个需求上传, 后端筛选出不为空的需求参数, 按需返回软件段列表
3. 最终将解析完毕的数据返回前端显示 
![获取软件段列表](../%E7%AC%AC%E4%B8%89%E5%91%A8%E5%B7%A5%E4%BD%9C/%E8%8E%B7%E5%8F%96%E8%BD%AF%E4%BB%B6%E6%AE%B5%E5%88%97%E8%A1%A8.png)
### 获取某个软件段的所有版本
首先根据前端传来数据对指定的软件版本获取所有的版本, 通过前端传递数据查询etcd得到软件段是否被删除的状态, 如果该软件段已经被删除, 那就不存在所有的版本; 未被删除使用软件段前缀并且去etcd中查询软件段的所有版本, 并且返回数据前端展示.  
![获取某个软件段的所有版本](../%E7%AC%AC%E4%B8%89%E5%91%A8%E5%B7%A5%E4%BD%9C/%E8%8E%B7%E5%8F%96%E6%9F%90%E4%B8%AA%E8%BD%AF%E4%BB%B6%E6%AE%B5%E7%9A%84%E6%89%80%E6%9C%89%E7%89%88%E6%9C%AC.png)
### 更新段绑定的席位列表信息
通过前端传递数据查询etcd得到软件段的绑定的列表信息, 根据segid查询软件段的段绑定席位的状态, 通过解析软件段详情获取前缀并且调用etcd接口去更新相同前缀的段的关联席位, 将新的软件段详情信息传给前端.
![更新段绑定的席位列表信息](../%E7%AC%AC%E4%B8%89%E5%91%A8%E5%B7%A5%E4%BD%9C/%E6%9B%B4%E6%96%B0%E6%AE%B5%E7%BB%91%E5%AE%9A%E7%9A%84%E5%B8%AD%E4%BD%8D%E5%88%97%E8%A1%A8%E4%BF%A1%E6%81%AF.png)
### 段卸载检测
根据前端获取的软件段id, 从数据库中获取数据软件段详情, 通过软件段前缀获取它的席位信息, 筛选出不是当前段但是已经安装的段记录, 并且从中找到依赖当前段的段前缀加入到返回的结果中, 最后返回被依赖信息的结果信息.
![段卸载检测](../%E7%AC%AC%E4%B8%89%E5%91%A8%E5%B7%A5%E4%BD%9C/%E6%AE%B5%E5%AE%89%E8%A3%85%E6%A3%80%E6%B5%8B.png)
### 段卸载
通过前端获取的软件段的id从etcd中查询到要卸载的软件段详情, 并且将重复IP的节点排除, 卸载时传入所有已安装的节点, 而后将席位安装记录更新, 完成逻辑上的卸载.
![段卸载](../%E7%AC%AC%E4%B8%89%E5%91%A8%E5%B7%A5%E4%BD%9C/%E6%AE%B5%E5%8D%B8%E8%BD%BD1.png)  
etcd后台监视, 发现有NewObj产生, 而后调用addEvent事件, 段安装controller启动时会先接收到event, 并且插入到workqueue, 卸载成功后更新软件段的安装记录.
![段卸载子流程](../%E7%AC%AC%E4%B8%89%E5%91%A8%E5%B7%A5%E4%BD%9C/%E6%AE%B5%E5%8D%B8%E8%BD%BD.png)
### 查询段安装记录详情
从前端获取安装时的InstallId, 根据id从etcd缓存中查询所有详情并且返回安装记录详情;
![查询段安装记录详情](../%E7%AC%AC%E4%B8%89%E5%91%A8%E5%B7%A5%E4%BD%9C/%E6%9F%A5%E8%AF%A2%E6%AE%B5%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95%E8%AF%A6%E6%83%85.png)
### 段安装记录列表
根据前端获取的id从etcd中查询到该软件段是否存在, 而后从etcd缓存中查找安装记录列表, 并且按照时间的倒叙排序;
![查找安装记录列表](../%E7%AC%AC%E4%B8%89%E5%91%A8%E5%B7%A5%E4%BD%9C/%E6%AE%B5%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95%E5%88%97%E8%A1%A8.png)

### 删除段上传缓存
1. 
根据upload 上传返回的uid, 查询上传的缓存地址, 并且删除地址以及缓存文件, 返回结果.
### 下载段文件
1. 
根据段文件id 获取软件段详情, 并且根据common中的DownloadUrl和文件名组成下载地址并且返回, 后端使用下载地址调用ctx中的包完成下载;
### 段安装
通过前端传递的软件段id从etcd 中获取软件段详情, 获取失败返回错误; 获取成功, 如果席位列表为空, 返回软件段安装席位为空;检测是否该软件段已经被安装, 如果没有被安装则根据获取的软件段详情查看是否依赖形成环路, 最后获取席位信息并且更新席位安装记录(写入etcd).
![段安装](../%E7%AC%AC%E4%B8%89%E5%91%A8%E5%B7%A5%E4%BD%9C/%E6%AE%B5%E5%AE%89%E8%A3%85.png)  
etcd后台监视, 发现有NewObj产生, 而后调用addEvent事件, 段安装controller启动时会先接收到event, 并且插入到workqueue, 而后拿到obj处理安装, 安装成功后更新软件段的安装记录.
![段安装controller](../%E7%AC%AC%E4%B8%89%E5%91%A8%E5%B7%A5%E4%BD%9C/%E6%AE%B5%E5%AE%89%E8%A3%851.png)
### 数据同步实现
通过`SDP client`拉取`SDP`中的段列表，与etcd中存储的段列表进行比对
1. 对于新增的段，通过`SDP client`从`SDP`中下载对应的段文件保存到共享存储，并解析段文件获取段基本信息构建段记录，向etcd中插入段记录（设置其`isLocal`字段为`false`，代表段非本地上传）
2. 对于删除的段，通过其在`SDP`中的id，找出etcd段记录中`remoteExtra.uid`字段与之匹配的记录，删除该条记录 ，同时删除共享存储中的段文件以及etcd中该段的安装记录（包括段安装日志）