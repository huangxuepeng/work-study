## 软件工程的图

## jwt
### 什么是jwt

## XSS 跨站脚本攻击
### 原理
1. 在web页面中植入script脚本代码
2. 当用户浏览web页面时, 脚本执行达到攻击用户的效果
3. XSS 主要是针对用户层面的攻击
### 分类
- 反射型
- 储存型
- DOM型(属于反射型) 改变url中的参数
区别: 反射型是把xss代码发送给用户, 用户主动点击; 存储型是将xss脚本储存到了服务器的数据库中, 用户被动失去个人信息

## uuid
1. 由特定的算法生成, 复杂的算法生成, 保证了唯一性, 但是只能由计算机生成
2. 不能人工指定, 如果人工指定, 重复性高
3. 可能会出现重复的现象(但是可能性极小, 忽略不计), 但是在同一时空下是唯一的
## context
### WithValue携带数据
- 携带一个数据, 可以不断的透传并且可以打印出结果(是通过context树传递的)
实例
```
const (
	KEY = "trace_id"
)
func NewRequestID() string {
	return strings.Replace(uuid.New().String(), "-", "", -1)
}
func NewRequestID() string {
	return strings.Replace(uuid.New().String(), "-", "", -1)
}
func NewContextWithTraceID() context.Context {
	ctx := context.WithValue(context.Background(), KEY, NewRequestID())
	return ctx
}
func main() {
	c := NewContextWithTraceID()
	fmt.Println(c) // 获取所有的参数内容
	ss := c.Value(KEY).(string)
	fmt.Println(ss)
}
```
- 注意事项
1. 不建议使用值传递参数
2. 因为携带的value 是k-v的形式存在, 所以建议k使用内置类型(值类型, 引用类型)
3. k-v 都是interface{}类型, 做类型断言时要注意健壮性(断言时返回一个bool类型)
### 超时控制
withTimeout或者withDeadline来做超时控制，当一次请求到达我们设置的超时时间，就会及时取消，不再往下执行, 他们都会返回cancelFunc方法, 可以通过调用这个方法实现提前取消, 建议自动取消后也要调用cancelFunc方法去停止定时减少不必要的资源浪费.
```
Linux 连接TCP的超时时间为127s, 127秒的原因: linux的默认值net.ipv4.tcp_syn_retries = 6, 
```
实例
```
func main()  {
    HttpHandler()
}

func NewContextWithTimeout() (context.Context,context.CancelFunc) {
    return context.WithTimeout(context.Background(), 3 * time.Second)
}

func HttpHandler()  {
    ctx, cancel := NewContextWithTimeout()
    defer cancel()
    deal(ctx)
}

func deal(ctx context.Context)  {
    for i:=0; i< 10; i++ {
        time.Sleep(1*time.Second)
        select {
        case <- ctx.Done():
            fmt.Println(ctx.Err())
            return
        default:
            fmt.Printf("deal time is %d\n", i)
        }
    }
}
```
### withCancel取消控制
日常业务开发中我们往往为了完成一个复杂的需求会开多个gouroutine去做一些事情，这就导致我们会在一次请求中开了多个goroutine确无法控制他们，这时我们就可以使用withCancel来衍生一个context传递到不同的goroutine中，当我想让这些goroutine停止运行，就可以调用cancel来进行取消。
```
func main()  {
    ctx,cancel := context.WithCancel(context.Background())
    go Speak(ctx)
    time.Sleep(10*time.Second)
    cancel()
    time.Sleep(1*time.Second)
}

func Speak(ctx context.Context)  {
    for range time.Tick(time.Second){
        select {
        case <- ctx.Done():
            fmt.Println("我要闭嘴了")
            return
        default:
            fmt.Println("balabalabalabala")
        }
    }
}
```