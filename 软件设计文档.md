# 功能概述
## 2.1 获取段列表 [get请求 /seg]
首先用户在前端进行操作并且向后端传回所需要展示的页数、每页需要的条数、前缀、文件名、版本号
安装状态、接口契约ID筛选（筛选出支持某个接口契约的段）。  
后端通过调用page.H，获取前端发送的本页的第一个数据的id以及每页的数据条数， 并且通过Set函数让这两个数据可以跨中间件被查询， list函数而后通过调用page中的GetOffset和GetLimit函数进行对已经获取的并且Set过后的页面信息Get到。  
而后调用同一文件下的buildSegFiltersFromCtx, 去获取前端输入的prefix, name, version, version, startTime, endTime,keyword, installStaus(安装状态),接口契约ID筛选并且返回一个以v1.Segmente为形参以bool为返回值的筛选函数切片。  
调用ListWithPage来获取带分页段列表（prefix相同的段只取版本最高的并且可以传入filter筛选）而后通过api.go中的List函数获取软件的详细信息。将ListWithPage返回得到软件段的详细信息进行遍历， 并且依次判断每个软件段的安装次数,如果次数大于0，将最近一次的安装记录写入到软件段的详情中，如果不的话直接格式化向前端发送数据即可（所有软件段的详细信息  以及所有的软件段的条数）  
### 获取段列表  
![获取段列表](../work/获取段列表.png "获取段列表.png")
## 2.2 获取段详情
绑定数据获取uid, 通过ShouldBindUri获取，如果获取失败，返回201，表单参数异常和错误详情；成功之后， 将拿到的软件段uid传给Detail函数，获取软件段详情和一个bool类型，如果使用前端传的uid去查询软件段详情， 对应的uid不存在软件段详情，则返回false, 之后会像前端传递404， 软件段不存在，并且退出函数；true之后，如果传回的软件段的安装次数大于0, 更新软件安装/卸载进度。之后返回以uid查询的软件段详情。
### 获取段详情
![获取段详情](../work/%E6%AE%B5%E8%AF%A6%E6%83%85.png "获取段详情.png")
## 2.3 获取段详情的依赖项的信息
绑定数据获取uid, 通过ShouldBindUri获取，如果获取失败，返回201，表单参数异常和错误详情；成功之后， 将拿到的软件段uid传给Detail函数，获取软件段详情和一个bool类型，如果使用前端传的uid去查询软件段详情， 对应的uid不存在软件段详情，则返回false, 之后会向前端传递404， 软件段不存在，并且退出函数；true之后，如果传回的软件段的安装次数大于0, 更新软件安装/卸载进度。通过detail.GetDataDepList获取软件依赖契约的长度，使用这个软件段所依赖的长度返回一个map[string]struct{}(此后使用dataNameSet表示)，之后向dataNameSet存入软件段依赖信息，如果dataNameSet的长度大于0，并发将软件段的依赖信息存入到contract；最后返回detail(软件段的信息， 包含了它所依赖的的信息'是否被删除， 服务图标， 数据单元')
### 获取段列表依赖项
![获取段详情的依赖信息](../work/%E6%AE%B5%E8%AF%A6%E6%83%85%EF%BC%88%E4%BE%9D%E8%B5%96%E9%A1%B9%EF%BC%89.png "段详情的依赖项")
## 2.4获取某个段的所有版本的段
从前端获取段id， 并且根据id获取软件段的详情，根据软件段的前缀调用GetSegmentsOfPrefix获取所有的相同前缀的软件段的历史版本， 并且依次更新安装记录；
### 获取某个段的所有版本的段
![获取某个段的所有版本的段](获取某个段的所有版本.png "获取某个段的所有版本.png")
## 2.5更新软件段的席位列表信息
前端获取软件段id和席位列表， 根据软件段的id查询该软件段的存在情况，不存在退出以下逻辑的执行，存在既可以更新软件段的席位列表信息，检查安装列表，判断是否需要更新， 而后把更新成功的数据替换查询到的原先查询到的软件段详情，并且返回这个软件段的详情。
### 更新软件段的席位列表信息
![更新软件段的席位列表信息](../work/更新软件段绑定的席位信息.png "更新软件段的席位列表信息")
## 2.6删除段
获取要删除的软件段的id，根据软件段的id获取此软件段的详细信息，依据软件段的前缀获取到该软件段的所有的版本，并且对获取的所有版本进行判断，如果他只有一个版本，并且这个版本还被其他的软件依赖，那么这个软件段拒绝被删除，直接退出以下逻辑。如果说这个软件段可以被删除，或者他的历史版本不止一个的话（如果说软件段的历史版本大于2个，那么删除一个也不会出现问题，因为依赖可以向下兼容一个版本），可以直接去删除用户需要删除的软件段，本操作只会执行逻辑上的删除。
### 删除段
![删除段](../work/%E5%88%A0%E9%99%A4%E6%AE%B5.png "删除段")
## 2.7上传段
检测上传到文件包是mpk,还是zip文件的格式，而后选择不同的功能函数去解决解压的问题，拿到解压的文件信息，去检验是否已经存在了这个软件段的相同前缀和版本号的软件段，如果说已经存在了当前上传的软件段，直接退出以下逻辑；而后检验和这个新上传的软件段的，而后把原来的信息复制一份到新上传的软件段，包括seats等一些信息，而后查看上传文件的具体信息，将拿到的文件信息存入到软件段信息，最后返回新上传的软件段信息。
### 上传段
![上传段](../work/%E4%B8%8A%E4%BC%A0%E6%AE%B5.png "上传段")
## 2.8删除段上传缓存
根据upload返回的id参数，查询软件段上传时的信息， 直接将文件夹删除， 完成删除缓存操作。
## 2.9添加段记录
## 2.10获取段文件的下载地址
验证软件段是否存在，而后判断段文件保存的地址是否存在,存在就返回下载地址+文件段文件名作为段文件名的下载地址
## 2.11下载段文件
根据获取到的软件详情, 并且拿到其中的FileName 而后调用gin框架中的FileAttachment函数, 完成以有效的方式将指定的文件写入正文流, 文件通过使用指定的文件名下载
## 2.12检测段绑定的席位是否包含可安装节点
获取软件段详情并且将软件段的的席位名列表取出, 而后获取到列表名的详细的席位信息, 并且通过cpu类型节点来筛选出这个给出的席位详细信息为满足和不满足的列表, 返回详细的席位分类列表
### 检测段绑定的席位是否包含可安装节点
![检测段绑定的席位是否包含可安装节点](../work/%E6%A3%80%E6%B5%8B%E6%AE%B5%E7%BB%91%E5%AE%9A%E7%9A%84%E5%B8%AD%E4%BD%8D%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E5%8F%AF%E5%AE%89%E8%A3%85%E8%8A%82%E7%82%B9.png "检测段绑定的席位是否包含可安装节点")
## 2.13 段安装
通过id获取到指定的软件段, 判断软件段的安装席位是否为空, 为空直接返回错误。 检测需要安装的是不是已经安装或者正在安装, 如果是,直接返回错误。检查软件的安装依赖是不是和自身形成了环路, 直接返回错误。最后给席位名创建记录, 并且返回记录。
### 段安装
![段安装](../work/%E6%AE%B5%E5%AE%89%E8%A3%85.png "段安装")
## 2.14 查询段安装记录详情
查询安装记录id并且拿到详情, 如果没有详情返回错误,有详情返回详情信息。
## 2.15 段安装记录列表
通过id验证是否该段存在, 并且通过id去查询返回所有的段安装列表。
## 2.16 段安装检测
检验段绑定的席位是否有能安装的节点, 并且要在席位列表中找到满足段cpu类型和不满足的并且返回席位的节点的满足与不满足的。
## 2.17 段卸载检测
根据传来的id 查询本软件段的安装席位是否为0, 如果为零, 就不需要执行以下的逻辑, 直接返回席位为空;而后获取所有的席位信息, 并且筛选出不是当前段的但是已经安装的段记录, 筛选出依赖这个段的段前缀并且加入到返回结果中, 最终返回结果。
## 2.18 段卸载
根据id判断安装节点,是否为空, 如果为空, 将返回软件段的安装席位为空, 不需要卸载; 不为空时, 将软件段的安装节点的席位名以及列表遍历出, 并且存储, 最后更新软件段的安装记录。
